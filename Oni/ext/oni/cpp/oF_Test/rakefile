require 'rake/testtask'
require 'rake/clean'
require 'fileutils'
require 'open3'

# generate depend file for gcc dependencies
# sh "gcc -MM *.c > depend"

NAME = 'oni'

# the same as before
Rake::TestTask.new do |t|
	# t.test_files = []
	
	# t.libs << 'test'

	t.test_files = ["test/test_node_creation.rb"]
end



# interactive command-line program execution
def run_i(cmd_string)
	stdin, stdout_and_stderr, wait_thr = Open3.popen2e cmd_string
	
	output = nil
	begin
		output = stdout_and_stderr.gets
		puts output
	end while output
	
	stdin.close
	stdout_and_stderr.close
end

def run_task(task)
	Rake::Task[task].invoke
	Rake::Task[task].reenable
	# src: http://stackoverflow.com/questions/577944/how-to-run-rake-tasks-from-within-rake-tasks
end






BASEPATH = File.absolute_path(File.dirname(__FILE__))
	# puts BASEPATH

CORE_BUILD_PATH = File.expand_path("./mySketch", BASEPATH)
LIB_OUTPUT_PATH = File.expand_path("./mySketch/lib", BASEPATH)

PLATFORM = "linux64"
TARGET   = "Release"

number_of_cores = 4
# TODO: accept platform, target, and number of cores as Rake arguments
# (maybe you actually want to figure out platform automatially)




task :default => :run

task :build => [:build_core, :build_library]
task :clean => [:clean_core, :clean_library]

# run just the C++ components
task :run => :build do
	Dir.chdir CORE_BUILD_PATH do
		run_i "make RunRelease"
	end
end

# build the library, but scrap the CPP-only executable
task :build_ext => :build do
	# TODO: current build system generates a C++ only executable. Delete that.
	# TODO: implement this
end






# generate all the .o files using the standard openFrameworks build system
task :build_core do
	Dir.chdir CORE_BUILD_PATH do
		run_i "make -j#{number_of_cores}"
	end
end

task :clean_core do
	Dir.chdir CORE_BUILD_PATH do
		run_i "make clean"
	end
end







# temporarily swap out the makefile for an alternate version
# 
# main_filepath, alt_filepath:  Paths to main and alt makefile, relative to common_root.
# common_root:                  As above.
# work_dir:                     Path under which to run the commands specified in the block.
def swap_makefile(common_root, main_filepath, alt_filepath, &block)
	swap_ext = ".temp"
	swap_filepath = File.join(common_root, "Makefile#{swap_ext}")
	
	Dir.chdir BASEPATH do # NOTE: this chdir may be unnecesary
		main_filepath = File.expand_path(File.join(common_root, main_filepath))
		alt_filepath  = File.expand_path(File.join(common_root, alt_filepath))
	end
	
	
	
	
	# run tasks associated with the alternate file
	begin
		FileUtils.mv main_filepath, swap_filepath # rename main makefile
		FileUtils.cp alt_filepath, main_filepath  # switch to .a-creating mkfile
		
		block.call
	ensure
		FileUtils.cp swap_filepath, main_filepath # restore temp
		FileUtils.rm swap_filepath                # delete temp		
		# I think this ensure block should make it so the Makefile always restores,
		# even if there is an error in the block.
		# src: http://stackoverflow.com/questions/2191632/begin-rescue-and-ensure-in-ruby
	end
end

# use a modified version of the oF build system to generate a C++ static lib
task :build_library => "mySketch/lib/libOFSketch.a"


local_oF_cpp_source = Dir.glob("mySketch/src/*{.cpp,.h}")
file "mySketch/lib/libOFSketch.a" => local_oF_cpp_source do
	run_task('clean_library')
	
	swap_makefile("./mySketch/", "Makefile", "Makefile.static_lib") do
		Dir.chdir CORE_BUILD_PATH do
			run_i "make static_lib"
		end
	end
end

task :clean_library do
	swap_makefile("./mySketch/", "Makefile", "Makefile.static_lib") do
		Dir.chdir CORE_BUILD_PATH do
			run_i "make clean_static_lib"
		end
	end
end





# a way to test that all variables needed to build the static lib are set
task :lib_variable_test do
	swap_makefile("./mySketch/", "Makefile", "Makefile.static_lib") do
		Dir.chdir CORE_BUILD_PATH do
			run_i "make variable_test"
		end
	end
end

# check what's in the static lib that's being outputted
# (linux and OS only)
task :lib_test do
	# NOTE: this can stay the same regaurdless of the library-building method
	Dir.chdir LIB_OUTPUT_PATH do
		# the -C flag is for de-mangling the C++ function names
		run_i "nm -C libOFSketch.a "
		
		# this command will let you see inside an .so
		# nm -C -D libfmodex.so
		# src: http://stackoverflow.com/questions/4514745/how-do-i-view-the-list-of-functions-a-linux-shared-library-is-exporting
	end
end










# show the .o files generated that are specific to this project
task :examine do
	path = File.expand_path("./mySketch/obj/#{PLATFORM}/#{TARGET}/src", BASEPATH)
	Dir.chdir path do
		puts "local oF build directory:"
		puts Dir.pwd
		p Dir['./*']
	end
end
