require 'rake/testtask'
require 'rake/clean'

require 'fileutils'
require 'open3'




# interactive command-line program execution
def run_i(cmd_string, &block)
	exit_status = nil
	Open3.popen2e(cmd_string) do |stdin, stdout_and_stderr, wait_thr|
		output = nil
		begin
			output = stdout_and_stderr.gets
			puts output
		end while output
		
		
		exit_status = wait_thr.value
	end
	
	if block
		# call the block if there is an error
		raise block.call if exit_status != 0
	end
	
	return exit_status
end

# invoke a particular rake task by name (and then allow it to be run again later)
def run_task(task)
	Rake::Task[task].reenable
	Rake::Task[task].invoke
	Rake::Task[task].reenable
	# src: http://stackoverflow.com/questions/577944/how-to-run-rake-tasks-from-within-rake-tasks
end


# temporarily swap out the makefile for an alternate version
# 
# main_filepath, alt_filepath:  Paths to main and alt makefile, relative to common_root.
# common_root:                  As above.
# work_dir:                     Path under which to run the commands specified in the block.
def swap_makefile(common_root, main_filepath, alt_filepath, &block)
	swap_ext = ".temp"
	swap_filepath = File.join(common_root, "Makefile#{swap_ext}")
	
	
	main_filepath = File.expand_path(File.join(common_root, main_filepath))
	alt_filepath  = File.expand_path(File.join(common_root, alt_filepath))
	
	
	
	
	# run tasks associated with the alternate file
	begin
		FileUtils.mv main_filepath, swap_filepath # rename main makefile
		FileUtils.cp alt_filepath, main_filepath  # switch to .a-creating mkfile
		
		block.call
	ensure
		FileUtils.cp swap_filepath, main_filepath # restore temp
		FileUtils.rm swap_filepath                # delete temp		
		# I think this ensure block should make it so the Makefile always restores,
		# even if there is an error in the block.
		# src: http://stackoverflow.com/questions/2191632/begin-rescue-and-ensure-in-ruby
	end
end





# generate depend file for gcc dependencies
# sh "gcc -MM *.c > depend"

NAME = 'oni'



# === this path is most likely not going to be under the root directory of the Ruby gem
OF_ROOT = "/home/ravenskrag/Experiments/OpenFrameworks/of_v0.9.3_linux64_release/"


# === these paths should be under the root directory of this Ruby gem
GEM_ROOT = File.absolute_path(File.dirname(__FILE__))


'ext/oni/cpp/oF_Test'
	'./mySketch'
	'./mySketch/lib'

CPP_ROOT = File.expand_path('ext/oni/cpp/', GEM_ROOT)

	OF_SKETCH_ROOT = File.expand_path('oF_Test/mySketch/', CPP_ROOT)
		
		OF_SKETCH_SRC_DIR         = File.expand_path('src', OF_SKETCH_ROOT)
		OF_SKETCH_SRC_FILES       = Dir.glob(File.join(OF_SKETCH_SRC_DIR, '*{.cpp,.h}'))
		
		OF_SKETCH_LIB_OUTPUT_PATH = File.expand_path('lib', OF_SKETCH_ROOT)
		

# === Other build configuration variables
OF_SKETCH_LIB_FILE = File.join(OF_SKETCH_LIB_OUTPUT_PATH, 'libOFSketch.a')
PLATFORM           = "linux64"
TARGET             = "Release"

number_of_cores = 4
# TODO: accept platform, target, and number of cores as Rake arguments
# (maybe you actually want to figure out platform automatially)



# use 'rake clean' and 'rake clobber' to
# easily delete generated files
CLEAN.include('ext/**/*{.o,.log,.so}')
# CLEAN.include('ext/**/Makefile')
CLOBBER.include('lib/**/*.so')
# CLOBBER.include('lib/**/*.gem') # fix this up. I do want to clobber the gem tho





# C++: main openFrameworks package, downloaded from the oF website
namespace :base do
	task :build do
		path = "scripts/linux"
		path = File.expand_path(path, OF_ROOT)
		Dir.chdir path do
			run_i "./compileOF.sh -j4" # build the core
			
			# run_i "./cleanAllExamples.sh"
			# run_i "./buildAllExamples.sh"
		end
	end
	
	task :clean do
		path = "libs/openFrameworksCompiled/project"
		path = File.expand_path(path, OF_ROOT)
		Dir.chdir path do
			run_i "make clean" # clean up the core
		end
	end
	
	task :rebuild do
		run_task('base:clean')
		run_task('base:build')
	end
end


# C++ / C: Compile the depencies for oF with the -fPIC flag
# These libraries are needed before final linking of the Ruby application.
# There is an analogous set of libs tha come with the oF package
# that are used for standard C++ sketch compilation,
# but those were not compiled with the -fPIC flag,
# so they will not link into a Ruby-compatible dynamic library.
# 
# (assumes the build environments for those libraries are already set up)
# (read "how dynamic lib compile was achived.odt" for an explanation / history)
namespace :dependencies do
	# assuming for 'tess2' that 'premake' was already run,
	# and makefiles have been altered to add -fPIC
	task :build_tess2 do
		folder = File.expand_path('../of_v0.9.3_libs/custom/tess2/Build', OF_ROOT)
		
		Dir.chdir folder do
			run_i "make"
		end
	end
	
	task :rebuild_tess2 do
		folder = File.expand_path('../of_v0.9.3_libs/custom/tess2/Build', OF_ROOT)
		
		Dir.chdir folder do
			run_i "make clean"
			run_i "make"
		end
	end
	
	task :run_tess2_example do
		folder = File.expand_path('../of_v0.9.3_libs/custom/tess2/Build', OF_ROOT)
		
		Dir.chdir folder do
			run_i "./example"
		end
	end
	
	
	# assuming for 'kiss' that 'cmake' was already run
	# and -fPIC flag has been added to the flags.make file
	task :build_kiss do
		folder = File.expand_path('../of_v0.9.3_libs/custom/kiss/build', OF_ROOT)
		
		Dir.chdir folder do
			run_i "make"
		end
	end
	
	task :rebuild_kiss do
		folder = File.expand_path('../of_v0.9.3_libs/custom/kiss/build', OF_ROOT)
		
		Dir.chdir folder do
			run_i "make clean"
			run_i "make"
		end
	end
	
	
	
	
	# all you need to build poco is here. no need for custom modification
	task :build_poco do
		folder = File.expand_path('../of_v0.9.3_libs/custom/poco/poco-1.7.4-all/', OF_ROOT)
		
		Dir.chdir folder do
			# run_i "./configure --static --no-shared-libs --no-tests --no-samples"
			run_i "./configure"
			run_i "make"
		end
	end
	
	task :rebuild_poco do
		folder = File.expand_path('../of_v0.9.3_libs/custom/poco/poco-1.7.4-all/', OF_ROOT)
		
		Dir.chdir folder do
			# run_i "./configure --static"
			run_i "make clean"
			run_i "make"
		end
	end
end


# C++ / C: particulars of one oF sketch.
#          Loads certain oF addons, compiles against the oF base setup
namespace :oF_sketch do
	# run just the C++ components for the oF sketch
	task :run => :build do
		Dir.chdir OF_SKETCH_ROOT do
			run_i "make RunRelease"
		end
	end
	
	
	# generate all the .o files using the standard openFrameworks build system
	task :build do
		Dir.chdir OF_SKETCH_ROOT do
			run_i "make -j#{number_of_cores}" do
				"ERROR: Could not build oF sketch."
			end
		end
	end

	task :clean do
		Dir.chdir OF_SKETCH_ROOT do
			run_i "make clean"
		end
	end
	
	
	
	# rebuilding the project should rebuild the addons too
	task :rebuild do
		run_task('oF_sketch:clean')
		run_task('oF_sketch:build')
	end
	
	
	
	
	# show the .o files generated that are specific to this project
	# (these are the files used to generate the static lib)
	task :examine do
		path = File.expand_path("obj/#{PLATFORM}/#{TARGET}/src", OF_SKETCH_ROOT)
		Dir.chdir path do
			puts "local oF build directory:"
			puts Dir.pwd
			p Dir['./*']
		end
	end
end


# C++: take the .o files generated by building the oF sketch and stitch them into a static lib.
#      (in later steps, this static lib --> dynamic lib required by Ruby)
namespace :oF_sketch_lib do
	# use a modified version of the oF build system to generate a C++ static lib
	task :build => OF_SKETCH_LIB_FILE
	
	
	
	file OF_SKETCH_LIB_FILE => OF_SKETCH_SRC_FILES do
		swap_makefile(OF_SKETCH_ROOT, "Makefile", "Makefile.static_lib") do
			Dir.chdir OF_SKETCH_ROOT do
				run_i "make static_lib" do
					"ERROR: Could not make a static library out of the oF sketch project."
				end
			end
		end
	end

	task :clean do
		swap_makefile(OF_SKETCH_ROOT, "Makefile", "Makefile.static_lib") do
			Dir.chdir OF_SKETCH_ROOT do
				run_i "make clean_static_lib"
			end
		end
	end
	
	task :rebuild do
		run_task('oF_sketch_lib:clean')
		run_task('oF_sketch_lib:build')
	end
	
	
	
	
	
	
	
	# a way to test that all variables needed to build the static lib are set
	task :variable_test do
		swap_makefile(OF_SKETCH_ROOT, "Makefile", "Makefile.static_lib") do
			Dir.chdir OF_SKETCH_ROOT do
				run_i "make variable_test"
			end
		end
	end
end



# === Build the C extension

# make the :test task depend on the shared
# object, so it will be built automatically
# before running the tests

# rule to build the extension: this says
# that the extension should be rebuilt
# after any change to the files in ext

c_library = "lib/#{NAME}/#{NAME}.so"


# TODO: update source file list
source_files = Array.new
# source_files += Dir.glob("ext/#{NAME}/*{.rb,.c}")


# Dir.glob("ext/#{NAME}/cpp/oF_Test/*{.cpp,.h}")
source_files += Dir.glob("ext/#{NAME}/**/*{.cpp,.h}")
source_files += ["ext/#{NAME}/extconf.rb", __FILE__]


# FIXME: can't seem to just run rake again to rebuild. keep having to clobber, and then do a full clean build again.



# Mimic RubyGems gem install procedure, for testing purposes.
# * run extconf
# * execute the resultant makefile
# * move the .so to it's correct location
file c_library => source_files do
	Dir.chdir("ext/#{NAME}") do
		# this does essentially the same thing
		# as what RubyGems does
		puts "=== starting extconf..."
		
		run_i "ruby extconf.rb" do
			"ERROR: Could not configure c extension."
		end
		
		
		puts "======= Top level Rakefile"
		puts "=== configuration complete. building C extension"
		
		
		# Run make
		
		flags = ""
		run_i "make #{flags}"  do
			"ERROR: Could not build c extension."
		end
	end
	
	cp "ext/#{NAME}/#{NAME}.so", "lib/#{NAME}"
end













# check what symbols are in the static lib generated by the oF base package.
task :dump_base_lib do
	Dir.chdir File.expand_path("libs/openFrameworksCompiled/lib/#{PLATFORM}", OF_ROOT) do
		# the -C flag is for de-mangling the C++ function names
		run_i "nm -C libopenFrameworks.a"
		
		# "/libs/openFrameworksCompiled/lib/linux64/libopenFrameworks.a(ofAppRunner.o)"
	end
end

# check what's in the static lib that's being outputted
# (linux and OSX only)
task :dump_sketch_lib do
	# NOTE: this can stay the same regaurdless of the library-building method
	Dir.chdir OF_SKETCH_LIB_OUTPUT_PATH do
		# the -C flag is for de-mangling the C++ function names
		run_i "nm -C libOFSketch.a "
		
		# this command will let you see inside an .so
		# nm -C -D libfmodex.so
		# src: http://stackoverflow.com/questions/4514745/how-do-i-view-the-list-of-functions-a-linux-shared-library-is-exporting
	end
end

# check what symbols are in the dynamic library
# (linux and OSX only)
task :dump_so do
	filepath = File.expand_path('lib/oni/oni.so', GEM_ROOT)
	run_i "nm -C -D #{filepath}"
end






task :build_dependencies => [
	'dependencies:build_tess2',
	'dependencies:build_kiss',
	'dependencies:build_poco'
]

task :rebuild_dependencies => [
	'dependencies:rebuild_tess2',
	'dependencies:rebuild_kiss',
	'dependencies:rebuild_poco'
]



# this will be used by extconf in deployment
task :build_core => [
	'base:build',
	'oF_sketch:build',
	'oF_sketch_lib:build'
]



# this is what you use while testing / developing

task :build => [
	'base:build',
	'oF_sketch:build',
	'oF_sketch_lib:build',
	:build_dependencies,
	c_library
]

task :rebuild_c_extension do
	run_task(c_library)
end


task :clean => [:clean_core, :clean_library]


# rebuild literally EVERYTHING. start with building oF core, and work your way up.
task :rebuild_everything => [
	'base:rebuild',
	'oF_sketch:rebuild',
	'oF_sketch_lib:rebuild',
	:rebuild_dependencies,
	c_library
] do
	
end

# build the library, but scrap the CPP-only executable
task :build_ext => :build do
	# TODO: current build system generates a C++ only executable. Delete that.
	# TODO: implement this
end


# run project from the Ruby level
task :run => :build do
	require File.expand_path(c_library, File.absolute_path(File.dirname(__FILE__)))
	# TODO: require the Ruby level class, instead of the C / C++ level one, so I can define some default behavior in Ruby
	# TODO: rename things so this project doesn't have symbol collision with the other package I named "Oni", from which this project's template derives.
	
	
	# TODO: Move Rice CPP files to another directory.
	# TODO: load basic window definition from a Ruby file, instead of defining here.
	# TODO: Update build system such that things don't have to rebuild just because you made a change to some Ruby code (should only rebuild when you need to update the C / C++ stuff.)
		# right now, things are rebuilding just because I edited this file.
		# but that may be because I'm editing the build system technically?
		# so gonna have to fix that.
	
	
	# TODO: wrap functions to set color of objects
	# TODO: wrap function to set background color
	# TODO: wrap functions to get window dimensions
	# TODO: consider marking all drawing methods as private from Ruby-land
	class Window < Oni::Window
		def initialize
			super(self) # pass Ruby instance to C++ land for callbacks, etc
			
			puts "ruby: Window#initialize"
			
			@p = [0,0]
		end
		
		def setup
			puts "ruby: Window#setup"
		end
		
		def update
			# puts "ruby: Window#update"
		end
		
		def draw
			puts "ruby: Window#draw"
			z = 1
			ofDrawCircle(*@p,z, 20)
			puts "draw complete"
		end
		
		def mouse_moved(x,y)
			p [x,y]
			
			@p = [x,y]
		end
		
		def mouse_pressed(x,y, button)
			p [:pressed, x,y, button]
			
			exit() if button == 4
			# TODO: set button codes as constants?
		end
		
		def mouse_released(x,y, button)
			p [:released, x,y, button]
		end
		
		def mouse_dragged(x,y, button)
			p [:dragged, x,y, button]
		end
		
		
		
		private
		
		def exit(status_code=0)
			super(status_code)
		end
	end
	
	x = Window.new
	x.show
end



# note that the dependency ensures
# the gem can not be packaged if
# the c extension component fails to build
task :package => c_library do
	`gem build oni.gemspec`
end


task :default => :build













# desc "Run tests"
# task :default => [:test, c_library]

task :test => c_library

# the same as before
Rake::TestTask.new do |t|
	# t.test_files = []
	
	# t.libs << 'test'
	# t.test_files = FileList['test/test*.rb']
end



# namespace :windows do
# 	task :package => :default do
# 		`gem build oni_win_precompiled.gemspec`		
# 	end
	
# 	task :release => Rake::Task['windows:package'] do
		
# 	end
# end
